// Blynk Connectivity
#define BLYNK_TEMPLATE_ID "TMPL27BKzsRQ4"
#define BLYNK_TEMPLATE_NAME "Tool Monitoring System"
#define BLYNK_AUTH_TOKEN "lZqeBkxG9GFmkrAKzZsgLurUtXkNEgV-"

#include <ZMPT101B.h>
#include <Wire.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <BlynkSimpleEsp32.h>
#include <LiquidCrystal_I2C.h>

#define BLYNK_PRINT Serial

char ssid[] = "MTN_4G_5EDE43";
char pass[] = "4WER55YU85";

#define POT_PIN 36
#define ZERO_CROSS_PIN 23
#define SCR_GATE_PIN 26
#define PUSH_BUTTON 14
#define IR_SENSOR_PIN 27
#define VOLTAGE_SENSOR 35
#define CURRENT_SENSOR 33
#define TEMP_SENSOR 25
#define PULSES_PER_REV 1
#define V_SENSITIVITY 573.00f
#define C_SENSITIVITY 0.1 // V/A according to datasheet for ACS712 20mA model
#define AC_FREQUENCY 50.0 // Hz

ZMPT101B voltageSensor(VOLTAGE_SENSOR, AC_FREQUENCY);
OneWire oneWire(TEMP_SENSOR);
DallasTemperature tempSensor(&oneWire);
LiquidCrystal_I2C lcd(0x27, 16, 2);

#define ADC_HIGH 4095 // due to 12 bit ADC resolution of esp32
#define AC_HALF_CYCLE_PERIOD 10000 // in microseconds

int firingDelay = 0; // in microseconds
volatile bool zeroCrossDetected = false;
volatile bool iotControl = false;
volatile int pulseCount = 0;
int rpm = 0;
float voltageReading = 0;
float currentReading = 0;
float temperatureReading = 0;

portMUX_TYPE taskMux = portMUX_INITIALIZER_UNLOCKED; // critical section mutex

// Interrupt Service Routine for Zero Crossing Detection
void IRAM_ATTR handleZeroCross() {
  zeroCrossDetected = true;
}

// Handle toggling action for the pushbuttons
// Interrupt Service Routine for Pushbutton toggle
void IRAM_ATTR handleButton() {
  iotControl = !iotControl;
}

// Interrupt Service Routine for Pulse generated by IR_SENSOR
void IRAM_ATTR handlePulse() {
  pulseCount++;
}

// Take potentiometer readings if control is manual
void readPotTask(void *pvParameters) {
  int potValue;

  while (1) {
    if (!iotControl) { // manual control
      potValue = analogRead(POT_PIN);

      // Map the potentiometer readings to timing for the firing delay
      firingDelay = map(potValue, 0, ADC_HIGH, 0, AC_HALF_CYCLE_PERIOD);
    }
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

// Turn on and off the SCR based on the signal from the ZCDC and potentiometer readings
void triggerSCRTask(void *pvParameters) {
  while (1) {
    if (zeroCrossDetected) {
      zeroCrossDetected = false;
      delayMicroseconds(firingDelay);
      digitalWrite(SCR_GATE_PIN, HIGH);
      delayMicroseconds(100);
      digitalWrite(SCR_GATE_PIN, LOW);
    } else {
      vTaskDelay(10 / portTICK_PERIOD_MS);
    }
  }
}

  // Use IR sensor as a tachometer
  void rpmTask(void *pvParameters) {
    int tempCount = 0;

    while (1)
    {
      vTaskDelay(1000 / portTICK_PERIOD_MS);

      portENTER_CRITICAL(&taskMux);
      tempCount = pulseCount;
      pulseCount = 0;
      portEXIT_CRITICAL(&taskMux);

    rpm = (tempCount / PULSES_PER_REV) * 60;
    Serial.print("RPM: ");
    Serial.println(rpm);
  }
}

// Monitor voltage from voltage sensor
void voltageTask(void *pvParameters) {

  while (1) {
    voltageReading = voltageSensor.getRmsVoltage();
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

// Monitor current from current sensor
void currentTask(void *pvParameters) {
  int samples = 1000, raw;
  float sum, voltage, offset = ADC_HIGH / 2, mean, rms;

  while (1) {
    sum = 0;
    for (int i = 0; i < samples; i++) {
      raw = analogRead(CURRENT_SENSOR);
      voltage = raw - offset;
      sum += voltage * voltage;
    }

    mean = sum / samples;
    rms = sqrt(mean);

    currentReading = (rms * 5.0 / ADC_HIGH) / C_SENSITIVITY;
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

// Monitor temperature from temperature sensor
void temperatureTask(void *pvParameters) {
  while (1) {
    // request temperature reading
    tempSensor.requestTemperatures();
    temperatureReading = tempSensor.getTempCByIndex(0);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

BLYNK_WRITE(V3) {
  iotControl = param.asInt();
  Serial.print("IoTControl: ");
  Serial.println(iotControl);
}

BLYNK_WRITE(V6) {
  firingDelay = map(param.asInt(), 0, 100, 0, AC_HALF_CYCLE_PERIOD);
  Serial.print("New percentage speed: ");
  Serial.println(param.asInt());
}

// Handle Blynk
void BlynkHandler(void *pvParameters) {
  float torque;

  while (1) {
    if (Blynk.connected()) {
      Blynk.run();
      if (!iotControl) Blynk.virtualWrite(V3, 0);
      Blynk.virtualWrite(V0, voltageReading);
      Blynk.virtualWrite(V1, currentReading);
      Blynk.virtualWrite(V2, temperatureReading);
      Blynk.virtualWrite(V5, rpm);
      torque = (voltageReading * currentReading) / (2 * 3.142 * rpm / 60);
      Blynk.virtualWrite(V4, torque);
    } else {
      // Try reconnecting if not connected
      Blynk.connect();
    }
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

void monitorTask(void *pvParameters) {
  while (1) {
    Serial.print("Free Heap: ");
    Serial.println(ESP.getFreeHeap());
    vTaskDelay(5000 / portTICK_PERIOD_MS);
  }
}

void wifiBlynkManagerTask(void *pvParameters) {
  while (1) {
    // If WiFi is not connected, reconnect
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("[WiFi] Disconnected! Trying to reconnect...");
      WiFi.disconnect();
      WiFi.begin(ssid, pass);

      // Wait for connection for up to 10 seconds
      int retries = 0;
      while (WiFi.status() != WL_CONNECTED && retries < 20) {
        vTaskDelay(500 / portTICK_PERIOD_MS);
        retries++;
        Serial.print(".");
      }
      
      if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\n[WiFi] Reconnected successfully.");
      } else {
        Serial.println("\n[WiFi] Failed to reconnect.");
      }
    }

    // If WiFi is connected but Blynk is not connected
    if (WiFi.status() == WL_CONNECTED && !Blynk.connected()) {
      Serial.println("[Blynk] Disconnected! Trying to reconnect...");
      Blynk.connect();
      if (Blynk.connected()) {
        Serial.println("[Blynk] Reconnected successfully.");
      } else {
        Serial.println("[Blynk] Failed to reconnect.");
      }
    }

    vTaskDelay(5000 / portTICK_PERIOD_MS); // Check every 5 seconds
  }
}

// Handle the updating of the LCD screen
void lcdTask(void *pvParameters) {
 vTaskDelay(1000 / portTICK_PERIOD_MS);

  while (1) {
    // lcd.clear();

    lcd.setCursor(0, 0);
    lcd.print("T:");
    lcd.print(temperatureReading, 1);
    lcd.print("C V:");
    lcd.print(voltageReading, 1);

    lcd.setCursor(0, 1);
    lcd.print("I:");
    lcd.print(currentReading, 1);
    lcd.print("A R:");
    lcd.print(rpm);

    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

void setup() {
  Serial.begin(115200);

  // Startup connection o IoT platform
  WiFi.begin(ssid, pass);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected to WiFi");

  Blynk.config(BLYNK_AUTH_TOKEN);
  Blynk.connect();

  // Set pin modes
  pinMode(POT_PIN, INPUT);
  pinMode(ZERO_CROSS_PIN, INPUT_PULLUP);
  pinMode(SCR_GATE_PIN, OUTPUT);
  pinMode(PUSH_BUTTON, INPUT_PULLUP);
  pinMode(IR_SENSOR_PIN, INPUT);
  pinMode(VOLTAGE_SENSOR, INPUT);
  pinMode(CURRENT_SENSOR, INPUT);

  voltageSensor.setSensitivity(V_SENSITIVITY);
  tempSensor.begin();
  // Inteprete signals from the Zero-Crossing Detection Circuit (ZCDC)
  attachInterrupt(digitalPinToInterrupt(ZERO_CROSS_PIN), handleZeroCross, FALLING);
  attachInterrupt(digitalPinToInterrupt(PUSH_BUTTON), handleButton, LOW);
  attachInterrupt(digitalPinToInterrupt(IR_SENSOR_PIN), handlePulse, FALLING);

  Wire.begin();       // Make sure I2C bus is ready
  lcd.init();
  lcd.backlight();

  xTaskCreatePinnedToCore(triggerSCRTask, "triggerSCRTask", 2048, NULL, 3, NULL, 0);
  xTaskCreatePinnedToCore(readPotTask, "readPotTask", 2048, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(rpmTask, "rpmTask", 2048, NULL, 2, NULL, 0);
  xTaskCreatePinnedToCore(voltageTask, "voltageTask", 2048, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(currentTask, "currentTask", 2048, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(temperatureTask, "temperatureTask", 2048, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(BlynkHandler, "Blynk Handler", 8192, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(monitorTask, "Monitor Task", 2048, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(wifiBlynkManagerTask, "WiFiBlynkManager", 4096, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(lcdTask, "LCD Task", 4096, NULL, 1, NULL, 0);
}

void loop() {
  // I'll just leave this nigga empty :)
}

